# BF: BrainFuck Interpreter
âŸ¨
  Parse
  Fold
  FlattenOffsets
  Init
  Step
âŸ©â‡

Parse â† {
  mâ†ğ•©âˆŠ"[]+-><,."
  ttâ†m/ğ•©

  # TODO: add asserts around bad brackets
  # TODO: add pretty error formating like https://github.com/mlochbaum/bqn-libs/blob/a30673b4797dbd6bf0a2c46982530a489b542e8d/json.bqn#L87C1-L87C8
  # TODO: use token index for error reporting
  # tiâ†m/â†•â‰ ğ•©

  tmâ†"[]+-><,."=âŒœtt
  dâ†+`-â—‹Â»Ë0â€¿1âŠtm
  pâŠ£{pâ†©(ğ•¨âŠËœ1-Ëœğ•¨â‹ğ•©)âŒ¾(ğ•©âŠ¸âŠ)p}Â´Ë˜2â†•âŠ”dâŠ£pâ†â†•â‰ d

  # TODO: measure perf and optimize
  # td stores different data depending on node type
  rmâ†(âŠ‘1â†‘âŒ½)Â¨âŠ”p               # rightmost children
  tdâ†0â¥ŠËœâ‰ p
  nâ†(1+âŠâŸœrm)sâ†(/âŸœp)Â»0âŠtm     # `[` jump past children
  tdâ†©nâŒ¾(sâŠ¸âŠ)td
  tdâ†©td+(1+p)Ã—1âŠtm           # `]` jump just past parent into loop again

  tdâ†©td+(2â€¿3âŠ¸âŠ+â—‹(-Ë)4â€¿5âŠ¸âŠ)tm # For `+-><` store the inc/dec amount +1/-1
  tdâ†©td+âˆ¨Ë(6â€¿7)âŠtm

  # update `-` to `+` and and `<` to `>`
  ttâ†©tt+('+'-'-')Ã—3âŠtm
  ttâ†©tt+('>'-'<')Ã—5âŠtm
  âŸ¨p, tt, tdâŸ©
}

# folds chains of + or > into a single single node 
Fold â† {
  pâ€¿ttâ€¿tdâ†ğ•©

  tmâ†"+>"=âŒœtt
  (+Ã—0âŠ¸â‰ )`âŒ¾âŒ½tdÃ—0âŠtm
  diâ†(Â»âŠ¸<dt)Ã—(+Ã—0âŠ¸â‰ )`âŒ¾âŒ½tdÃ—dtâ†0âŠtm
  piâ†(Â»âŠ¸<pt)Ã—(+Ã—0âŠ¸â‰ )`âŒ¾âŒ½tdÃ—ptâ†1âŠtm
  tdâ†©i+tdÃ—i0â†0=iâ†di+pi

  kâ†Â¬râ†(dt+pt)Ã—i0

  ttâ†©k/tt
  tdâ†©k/td

  pâ†©(/r)(âŠ¢-â‹)k/p
  anâ†(/r)(âŠ¢-â‹)tdÃ—mâ†+Ë"[]"=âŒœtt
  tdâ†©an+tdÃ—Â¬m

  âŸ¨p, tt, tdâŸ©
}

# switch to only having + and no >.
# + will also store the offset to increment at.
# [ and ] will store increment for the entire block.
FlattenOffsets â† {
  pâ€¿ttâ€¿tdâ†ğ•©

  # this has ungroup which is probably slow.
  # probably can do it some other way?
  kâ†Â¬râ†'>'=tt
  oâ†gâŠ”â¼+`Â¨(rÃ—td)âŠ”Ëœgâ†0Â»+`ttâˆŠ"[]"

  ttâ†©k/tt
  tdâ†©k/td
  oâ†©k/o

  pâ†©(/r)(âŠ¢-â‹)k/p
  # when we remove a jump target this has issues
  # maybe add 1 if the jump target is a value being removed?
  # so if 5 is in r and a > make it 6? or the next non > character
  # This +0.1 is a hack that I assume really hurts perf.
  anâ†(0.1+/r)(âŠ¢-â‹)tdÃ—mâ†+Ë"[]"=âŒœtt
  tdâ†©an+tdÃ—Â¬m

  âŸ¨p, tt, td, oâŸ©
}

Init â† {
  dâ†0â¥ŠËœğ•¨âŠ£30000
  ipâ†0
  dpâ†0
  âŸ¨ip, dp, dâŸ©â€¿ğ•©
}

Step â† {
  âŸ¨ip, dp, dâŸ©â€¿âŸ¨p, tt, td, oâŸ©â†ğ•©

  idâ†ipâŠ‘td
  ioâ†ipâŠ‘o
  doâ†dp+io
  sâ†{
    '+': âŸ¨ip+1, dp, (256|idâŠ¸+)âŒ¾(doâŠ¸âŠ‘)dâŸ©;
    '[': jâ†0=doâŠ‘d â‹„ âŸ¨(jÃ—id)+(Â¬j)Ã—ip+1, do, dâŸ©;
    ']': jâ†0â‰ doâŠ‘d â‹„ âŸ¨(jÃ—id)+(Â¬j)Ã—ip+1, do, dâŸ©;
    '.': â€¢term.OutRaw <@+doâŠ‘d â‹„ âŸ¨ip+1, dp, dâŸ©;
    ',': câ†â€¢term.CharB@ â‹„ âŸ¨ip+1, dp, câŒ¾(doâŠ¸âŠ‘)dâŸ©
  }ipâŠ‘tt
  sâ€¿âŸ¨p, tt, td, oâŸ©

  # below is an attempt at being more "array" style
  # less branching and more masking
  # it also works, but is about 4x slower
  # odâ€¿cdâ€¿ddâ€¿pdâ€¿inâ€¿outâ†(ipâŠ‘td)Ã—itâ†"[]+>,."=ipâŠ‘tt

  # otâ†0âŠ‘it
  # ctâ†1âŠ‘it
  
  # dâ†©(256|ddâŠ¸+)âŒ¾(dpâŠ¸âŠ‘)d
  # dâ†©{in ? â€¢term.CharB@; ğ•©}âŒ¾(dpâŠ¸âŠ‘)d
  # # {out ? â€¢term.OutRaw <@+dpâŠ‘d; 0}

  # nzâ†Â¬zâ†0=dpâŠ‘d
  # # ipâ†©(odÃ—z)+(cdÃ—nz)+((zâˆ§Â¬ot)âˆ¨nzâˆ§Â¬ct)Ã—ip+1
  # ipâ†©ip+1
  # ipâ†©(cdÃ—nz)+(zâˆ¨Â¬ct)Ã—ip
  # ipâ†©(odÃ—z)+(nzâˆ¨Â¬ot)Ã—ip
  # dpâ†©dp+pd

  # âŸ¨ip, dp, dâŸ©â€¿âŸ¨p, tt, tdâŸ©
}
