# BF: BrainFuck Interpreter
âŸ¨
  Parse
  Fold
  FlattenOffsets
  Dedup
  Init
  Step
âŸ©â‡

Parse â† {
  mâ†ğ•©âˆŠ"[]+-><,."
  ttâ†m/ğ•©

  # TODO: add asserts around bad brackets
  # TODO: add pretty error formating like https://github.com/mlochbaum/bqn-libs/blob/a30673b4797dbd6bf0a2c46982530a489b542e8d/json.bqn#L87C1-L87C8
  # TODO: use token index for error reporting
  # tiâ†m/â†•â‰ ğ•©

  tmâ†"[]+-><,."=âŒœtt
  dâ†+`-â—‹Â»Ë0â€¿1âŠtm
  pâŠ£{pâ†©(ğ•¨âŠËœ1-Ëœğ•¨â‹ğ•©)âŒ¾(ğ•©âŠ¸âŠ)p}Â´Ë˜2â†•âŠ”dâŠ£pâ†â†•â‰ d

  # TODO: measure perf and optimize
  # td stores different data depending on node type
  rmâ†(âŠ‘1â†‘âŒ½)Â¨âŠ”p               # rightmost children
  tdâ†0â¥ŠËœâ‰ p
  nâ†(1+âŠâŸœrm)sâ†(/âŸœp)Â»0âŠtm     # `[` jump past children
  tdâ†©nâŒ¾(sâŠ¸âŠ)td
  tdâ†©td+(1+p)Ã—1âŠtm           # `]` jump just past parent into loop again

  tdâ†©td+(2â€¿3âŠ¸âŠ+â—‹(-Ë)4â€¿5âŠ¸âŠ)tm # For `+-><` store the inc/dec amount +1/-1
  tdâ†©td+âˆ¨Ë(6â€¿7)âŠtm

  # update `-` to `+` and and `<` to `>`
  ttâ†©tt+('+'-'-')Ã—3âŠtm
  ttâ†©tt+('>'-'<')Ã—5âŠtm
  âŸ¨p, tt, tdâŸ©
}

# folds chains of + or > into a single single node 
Fold â† {
  pâ€¿ttâ€¿tdâ†ğ•©

  tmâ†"+>"=âŒœtt
  (+Ã—0âŠ¸â‰ )`âŒ¾âŒ½tdÃ—0âŠtm
  diâ†(Â»âŠ¸<dt)Ã—(+Ã—0âŠ¸â‰ )`âŒ¾âŒ½tdÃ—dtâ†0âŠtm
  piâ†(Â»âŠ¸<pt)Ã—(+Ã—0âŠ¸â‰ )`âŒ¾âŒ½tdÃ—ptâ†1âŠtm
  tdâ†©i+tdÃ—i0â†0=iâ†di+pi

  kâ†Â¬râ†(dt+pt)Ã—i0

  ttâ†©k/tt
  tdâ†©k/td

  pâ†©(/r)(âŠ¢-â‹)k/p
  anâ†(/r)(âŠ¢-â‹)tdÃ—mâ†+Ë"[]"=âŒœtt
  tdâ†©an+tdÃ—Â¬m

  âŸ¨p, tt, tdâŸ©
}

# switch to only having + and no >.
# + will also store the offset to increment at.
# [ and ] will store increment for the entire block.
FlattenOffsets â† {
  pâ€¿ttâ€¿tdâ†ğ•©

  # this has ungroup which is probably slow.
  # probably can do it some other way?
  kâ†Â¬râ†'>'=tt
  oâ†gâŠ”â¼+`Â¨(rÃ—td)âŠ”Ëœgâ†0Â»+`ttâˆŠ"[]"

  ttâ†©k/tt
  tdâ†©k/td
  oâ†©k/o

  pâ†©(/r)(âŠ¢-â‹)k/p
  anâ†(/r)(âŠ¢-(â‹-âˆŠËœ))tdÃ—mâ†+Ë"[]"=âŒœtt
  tdâ†©an+tdÃ—Â¬m

  âŸ¨p, tt, td, oâŸ©
}

# merge repeated updates to the same offset.
# then any chain of `+` should be valid to execute in parallel.
Dedup â† {
  # TODO: actually implement instead of just hoping...
  # in any well written bf program, hoping should be safe though.
  âŸ¨p, tt, td, oâŸ©â†ğ•©
  râ†(+Ã—0âŠ¸â‰ )`âŒ¾âŒ½'+'=tt
  âŸ¨p, tt, td, o, râŸ©
}

Init â† {
  dâ†0â¥ŠËœğ•¨âŠ£30000
  ipâ†0
  dpâ†0
  âŸ¨Â·, tt, td, o, râŸ©â†ğ•©
  âŸ¨ip, dp, dâŸ©â€¿âŸ¨tt, td, o, râŸ©
}

Step â† {
  âŸ¨ip, dp, dâŸ©â€¿âŸ¨tt, td, o, râŸ©â†ğ•©

  idâ†ipâŠ‘td
  ioâ†ipâŠ‘o
  doâ†dp+io
  sâ†{
    '+':
      irâ†ipâŠ‘r
      midâ†irâ†‘ipâ†“td
      mdoâ†dp+irâ†‘ipâ†“o
      âŸ¨ip+ir, dp, (256|midâŠ¸+)âŒ¾(mdoâŠ¸âŠ)dâŸ©;
    '[': jâ†0=doâŠ‘d â‹„ âŸ¨(jÃ—id)+(Â¬j)Ã—ip+1, do, dâŸ©;
    ']': jâ†0â‰ doâŠ‘d â‹„ âŸ¨(jÃ—id)+(Â¬j)Ã—ip+1, do, dâŸ©;
    '.': â€¢term.Flush â€¢term.OutRaw â‹ˆ@+doâŠ‘d â‹„ âŸ¨ip+1, dp, dâŸ©;
    ',': câ†@-Ëœâ€¢term.CharB@ â‹„ âŸ¨ip+1, dp, câŒ¾(doâŠ¸âŠ‘)dâŸ©
  }ipâŠ‘tt
  sâ€¿âŸ¨tt, td, o, râŸ©
}
